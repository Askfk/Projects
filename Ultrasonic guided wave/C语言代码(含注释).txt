 #include <reg52.h>
 #include <stdio.h>
 #include <intrins.h>
 #include "1602.h"
 
 sbit P10 = P1^0;
 sbit P21 = P2^1;
// sbit P26 = P2^6;
 sfr T2MOD = 0xC9;

 unsigned int h = 1;	//LCD1602翻页标志位
 
 unsigned int b = 0;	//车辆数
 unsigned int a = 0;	//无车辆通过时自high用
 unsigned int z = 0; 	//判断是否有车辆进入标志位
 unsigned int sum = 0;	//记录58us个数
 unsigned int f = 0;	//最终距离
 
 unsigned int s1 = 0; 	//* 计算车速参数
 unsigned int s2 = 0;	//*
 unsigned int t1 = 0; 	//*
 unsigned int t2 = 0;	//*
 unsigned int v = 0; 	//*
 unsigned int c = 0; 	//* 两次测算标志位
  
 char showdis[16];
 char showsum[16];
 char showv[16];
 char str1[] = "sum of cars";
 char str2[] = "dis";
 char str3[] = "V";

 void display();
 void delay35ms();
 void delay2ms();
 void delay51us();
 
 void main(void){
	int j;
	for(j=0;j<5;j++)						  //* 此两句代码针对传感器与单片机同时启动时
		delay35ms();						  //* 进行175ms的延时（超声波传感器启动时间为175ms）
 	while(1){
		sum = 0;
		a = 0;;
		while(P10 == 0){					 //* 当P1.0为0（低电平，无物体供过）时，等待
			a = -a;							 //*
		}									 //* 当P1.0为0（低电平，无物体供过）时，等待
	
		while(P10 == 1){					 //* 当P1.0为1（高电平，有物体通过）时，进行脉冲宽度计算
			delay51us();					 //* 使用STC-ICP自动生成的延时代码中，延时51us的误差为0,
			sum++;							 //* 当P1.0为1（高电平，有物体通过）时，进行脉冲宽度计算
		}
		
		f = sum*30/58;						 //* 消去指令周期带来的距离测量误差


		if(f < 300 && f > 20){				 //* 当计算的距离小于3m大于20cm判断有物体进入
			z = 1;							 //* 此时把标志位置1，表示测量范围内有物体
		}									 //*

	//	c++;								 //*计算车速代码
	//	if(c == 1 && z == 1){				 //*
	//	   	s1 = sum/100;					 //*
	//		t1 = s1*2/340;					 //*
	//	}									 //*
	//	if(c == 2 && z == 1){				 //* 这段代码还有一些小BUG，先注释掉~
	//	   	s2 = sum/100;					 //*
	//		t2 = s2*2/340;					 //*
	//	}									 //*
											 //*
	//	if(c == 2 && z == 1){				 //*
	//	   	v = 2*(s1-s2)/(t1+t2);			 //*
	//		c = 0;							 //*
	//	}									 //* 计算车速代码

		if(f > 300 && z == 1){				 //* 判断测量距离是否小于3m以判断范围内物体是否离开
			b++;							 //* 若物体离开，则车辆数加一
			z = 0;							 //* 车辆标志位转化为无车状态
		}
		if(P21 == 0){						 //* 控制LCD1602显示器翻页
			delay2ms(); //延时消抖			 //* 把P2.1接入独立按键的某一个
			if(P21 == 0){					 //* 当按键按下时跳转到另一页
			h = -h;							 //*（共设置了两页）h默认是1，当按键按下取反
			}								 //*（如无按键按下，默认显示车辆数和距离）
		}									 //* 控制LCD1602显示器翻页
	//   	delay35ms();
	//	delay35ms();
		display();							 //* 调用显示函数
	} 	
}

void delay35ms(void)	//35毫秒@11.0592MHz
{
	T2MOD = 0;			//初始化模式寄存器
	T2CON = 0;			//初始化控制寄存器
	TL2 = 0x00;			//设置定时初值
	TH2 = 0x82;			//设置定时初值
	RCAP2L = 0x00;		//设置定时重载值
	RCAP2H = 0x82;		//设置定时重载值
	TR2 = 1;			//定时器2开始计时
}

void delay2ms(void)		//2毫秒@11.0592MHz
{
	AUXR |= 0x80;		//定时器时钟1T模式
	TMOD &= 0xF0;		//设置定时器模式
	TL0 = 0x9A;		//设置定时初值
	TH0 = 0xA9;		//设置定时初值
	TF0 = 0;		//清除TF0标志
	TR0 = 1;		//定时器0开始计时
}





void delay51us(void)	//51微秒@11.0592MHz
{
	AUXR |= 0x80;		//定时器时钟1T模式
	TMOD &= 0xF0;		//设置定时器模式
	TL0 = 0xCC;			//设置定时初值
	TH0 = 0xFD;			//设置定时初值
	TF0 = 0;			//清除TF0标志
	TR0 = 1;			//定时器0开始计时
}

void display()
{	BYTE i;
	lcd_init();								  //* 清空LCD1602显示屏的显示内容

	sprintf(showsum,"%s:%d",str1,b);		  //* 利用sprintf()函数将测量数据压入数组
	sprintf(showdis,"%s(cm):%d",str2,f);	  //* showsum储存车辆数，showdis储存距离，showv储存速度
	sprintf(showv,"%s:%dm/s",str3,v);		  //*
	
	
	if(h == 1){
	lcd_pos(0x00);							  //* LCD1602液晶显示屏可以显示两行内容
	i = 0;									  //* 每一行可以显示16个字节的内容
	while(showsum[i] != '\0')				  //* 第一行的起始位置为0x00,结束位置为0x0f
	{										  //* 第二行的起始位置为0x40,结束为止为0x4f
		lcd_wdat(showsum[i]);				  //* lcd_pos()函数标志显示内容的起始位置
		i++;
	}
	
	lcd_pos(0x40);
	i = 0;
	while(showdis[i] != '\0')
	{
		lcd_wdat(showdis[i]);
		i++;
	}
	}
	else if(h == -1){
	lcd_pos(0x00);
	i = 0;
	while(showv[i] != '\0')
	{
		lcd_wdat(showv[i]);
		i++;
	}
	}
	else{
	lcd_pos(0x00);
	i = 0;
	while(showsum[i] != '\0')
	{
		lcd_wdat(showsum[i]);
		i++;
	}
	
	lcd_pos(0x40);
	i = 0;
	while(showdis[i] != '\0')
	{
		lcd_wdat(showdis[i]);
		i++;
	}
	
	}
}
