 #include <reg52.h>
 #include <stdio.h>
 #include <intrins.h>
 #include "1602.h"
 
 sbit P10 = P1^0;
 sbit P21 = P2^1;
 sbit P31 = P3^1;
 sfr T2MOD = 0xC9;

 unsigned int h = 1;	//LCD1602翻页标志位
 
 unsigned int b = 0;	//车辆数
 unsigned int a = 0;	//无车辆通过时自high用
 unsigned int z = 0; 	//判断是否有车辆进入标志位
 unsigned int sum = 0;	//记录58us个数
 unsigned int f = 0;	//最终距离
 
 unsigned int s1 = 0; 	//* 计算车速参数
 unsigned int s2 = 0;	//*
 unsigned int t1 = 0; 	//*
 unsigned int t2 = 0;	//*
 unsigned int v = 0; 	//*
 unsigned int c = 0; 	//* 两次测算标志位 
 
 unsigned char k;		//串口通信判断字符位置
  char MESSAGE[4];
  
 char showdis[16];
 char showsum[16];
 char showv[16];
 char str1[] = "sum";
 char str2[] = "dis";
 char str3[] = "V";



 void display();
 void delay35ms();
 void delay2ms();
 void delay51us();
 
 void main(void){
 	 int j;
  		SCON = 0x50;       //REN=1允许串行接受状态，串口工作模式2     	   
	    TMOD|= 0x20;      //定时器工作方式2                       
		PCON|= 0x80;      //波特率提高一倍                                                    
   	       
	    TH1 = 0xF3;					// //baud*2  /*  波特率4800、数据位8、停止位1。效验位无 (12M)
    	TL1 = 0xF3; 
		TR1  = 1;        //开启定时器1                                                      
		ES   = 1;        //开串口中断                  
		EA   = 1;        // 开总中断

	for(j=0;j<5;j++)						  //* 此两句代码针对传感器与单片机同时启动时
		delay35ms();						  //* 进行175ms的延时（超声波传感器启动时间为175ms）
 	while(1){
		sum = 0;
		a = 0;;
		while(P10 == 0){					 //* 当P1.0为0（低电平，无物体供过）时，等待
			a = -a;							 //*
		}									 //* 当P1.0为0（低电平，无物体供过）时，等待
	
		while(P10 == 1){					 //* 当P1.0为1（高电平，有物体通过）时，进行脉冲宽度计算
			delay51us();					 //* 使用STC-ICP自动生成的延时代码中，延时51us的误差为0,
			sum++;							 //* 当P1.0为1（高电平，有物体通过）时，进行脉冲宽度计算
		}
		
		f = sum*30/58;						 //* 消去指令周期带来的距离测量误差

	    sprintf(MESSAGE,"%d",f);


		if(f < 300 && f > 20){				 //* 当计算的距离小于3m大于20cm判断有物体进入
			z = 1;							 //* 此时把标志位置1，表示测量范围内有物体
		}									 //*


		if(f > 300 && z == 1){				 //* 判断测量距离是否小于3m以判断范围内物体是否离开
			b++;							 //* 若物体离开，则车辆数加一
			z = 0;							 //* 车辆标志位转化为无车状态
		}
		if(P21 == 0){						 //* 控制LCD1602显示器翻页
			delay2ms(); //延时消抖			 //* 把P2.1接入独立按键的某一个
			if(P21 == 0){					 //* 当按键按下时跳转到另一页，单片机独立按键默认置1
			h = -h;							 //*（共设置了两页）h默认是1，当按键按下取反
			}								 //*（如无按键按下，默认显示车辆数和距离）
		}									 //* 控制LCD1602显示器翻页

	    P0 = 0;
		k = 0;                               // 屏蔽干扰	
	   while(MESSAGE[k] != '\0')
   	   {
		SBUF = MESSAGE[k];	                 //SUBF接受/发送缓冲器(又叫串行通信特殊功能寄存器)
         while(!TI);				         // 等特数据传送	(TI发送中断标志)
		 TI = 0;					         // 清除数据传送标志		
		 k++;					             // 下一个字符
       } 

		display();							 //* 调用显示函数
	} 	
}

void delay35ms(void)	//35毫秒@11.0592MHz
{
	T2MOD = 0;			//初始化模式寄存器
	T2CON = 0;			//初始化控制寄存器
	TL2 = 0x00;			//设置定时初值
	TH2 = 0x82;			//设置定时初值
	RCAP2L = 0x00;		//设置定时重载值
	RCAP2H = 0x82;		//设置定时重载值
	TR2 = 1;			//定时器2开始计时
}

void delay2ms(void)		//2毫秒@11.0592MHz
{
	AUXR |= 0x80;		//定时器时钟1T模式
	TMOD &= 0xF0;		//设置定时器模式
	TL0 = 0x9A;		//设置定时初值
	TH0 = 0xA9;		//设置定时初值
	TF0 = 0;		//清除TF0标志
	TR0 = 1;		//定时器0开始计时
}





void delay51us(void)	//51微秒@11.0592MHz
{
	AUXR |= 0x80;		//定时器时钟1T模式
	TMOD &= 0xF0;		//设置定时器模式
	TL0 = 0xCC;			//设置定时初值
	TH0 = 0xFD;			//设置定时初值
	TF0 = 0;			//清除TF0标志
	TR0 = 1;			//定时器0开始计时
}

void display()
{	BYTE i;
	lcd_init();								  //* 清空LCD1602显示屏的显示内容

	sprintf(showsum,"%s:%d",str1,b);		  //* 利用sprintf()函数将测量数据压入数组
	sprintf(showdis,"%s(cm):%d",str2,f);	  //* showsum储存车辆数，showdis储存距离，showv储存速度
	sprintf(showv,"%s:%dm/s",str3,v);		  //*
	
	
	if(h == 1){
	lcd_pos(0x00);							  //* LCD1602液晶显示屏可以显示两行内容
	i = 0;									  //* 每一行可以显示16个字节的内容
	while(showsum[i] != '\0')				  //* 第一行的起始位置为0x00,结束位置为0x0f
	{										  //* 第二行的起始位置为0x40,结束为止为0x4f
		lcd_wdat(showsum[i]);				  //* lcd_pos()函数标志显示内容的起始位置
		i++;
	}
	
	lcd_pos(0x40);
	i = 0;
	while(showdis[i] != '\0')
	{
		lcd_wdat(showdis[i]);
		i++;
	}
	}
	else if(h == -1){
	lcd_pos(0x00);
	i = 0;
	while(showv[i] != '\0')
	{
		lcd_wdat(showv[i]);
		i++;
	}
	}
	else{
	lcd_pos(0x00);
	i = 0;
	while(showsum[i] != '\0')
	{
		lcd_wdat(showsum[i]);
		i++;
	}
	
	lcd_pos(0x40);
	i = 0;
	while(showdis[i] != '\0')
	{
		lcd_wdat(showdis[i]);
		i++;
	}
	
	}
}
